선택정렬, 버블정렬, 삽입정렬은 모두 기본적인 비교 기반 정렬 알고리즘입니다.

이들은 복잡한 데이터 구조보다 `단순 배열`에 잘 작동하며, 주로 `작은 또는 거의 정렬된 데이터`에 효율적입니다.

<br>

### 🔷 선택정렬 (Selection Sort)
리스트에서 가장 작은 요소를 찾아서 선택한 다음, 리스트의 맨 앞에 위치한 요소와 교환하는 과정을 반복합니다. 첫 번째 원소부터 마지막 원소까지 이 과정을 반복하며 정렬을 완성합니다.

#### 복잡도:
- 최악, 평균, 최선 시간 복잡도: 𝑂(𝑛2)
- 공간 복잡도: 𝑂(1) (제자리 정렬)

#### 사용 상황:
데이터 양이 매우 적을 때 적합합니다. 데이터의 초기 순서와 무관하게 동일한 시간 복잡도를 가집니다.

<br>

### 🔷 버블정렬 (Bubble Sort)
인접한 두 요소의 크기를 비교하고, 필요한 경우 위치를 교환합니다. 이 과정을 리스트의 끝까지 반복하며, 가장 큰 요소가 리스트의 맨 끝으로 "버블링"(이동)됩니다. 이 과정을 리스트의 모든 요소가 정렬될 때까지 반복합니다.

#### 복잡도:
- 최악 시간 복잡도: 𝑂(𝑛2)
- 평균 시간 복잡도: 𝑂(𝑛2)
- 최선 시간 복잡도: 𝑂(𝑛) (이미 정렬된 배열의 경우)
- 공간 복잡도: 𝑂(1) (제자리 정렬)

#### 사용 상황:
간단한 코드가 필요하고, 데이터 양이 매우 적을 때 사용하기 좋습니다. 데이터가 이미 거의 정렬된 상태라면 효율적으로 작동할 수 있습니다.

<br>

### 🔷 삽입정렬 (Insertion Sort)
각 반복에서 하나의 데이터를 선택하여 이미 정렬된 배열 부분에 적절한 위치를 찾아 삽입하는 방식으로 작동합니다. 이 과정을 통해 배열이 점진적으로 정렬됩니다.

#### 복잡도:
- 최악 시간 복잡도: 𝑂(𝑛2)
- 평균 시간 복잡도: 𝑂(𝑛2)
- 최선 시간 복잡도: 𝑂(𝑛) (이미 정렬된 배열의 경우)
- 공간 복잡도: 𝑂(1) (제자리 정렬)

#### 사용 상황:
데이터가 거의 정렬되어 있거나, 실시간으로 데이터가 추가되어 점진적인 정렬이 필요할 때 유용합니다. 예를 들어, 사용자 입력을 받아 순차적으로 정렬해야 하는 상황에 적합합니다.

<br>

### 차이점
- 효율성: 세 알고리즘 모두 최악의 경우 𝑂(𝑛2)의 시간 복잡도를 가지지만, 삽입정렬과 버블정렬은 최선의 경우 𝑂(𝑛)의 시간 복잡도를 보일 수 있어, 거의 정렬된 데이터에 더 효율적입니다.
- 구현의 단순성: 버블정렬은 구현이 가장 간단하지만, 일반적으로 효율성이 가장 낮습니다. 선택정렬은 항상 𝑂(𝑛2)의 성능을 보이며, 삽입정렬은 조건에 따라 매우 효율적일 수 있습니다.
