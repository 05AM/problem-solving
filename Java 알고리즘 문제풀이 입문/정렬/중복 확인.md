### ✍🏻 스스로 풀기

#### 💡 삽입 정렬 사용

``` java
private String solution(int size, int[] numbers) {
  for (int i = 1; i < size; i++) {
    int target = numbers[i];
    int j;

    for (j = i - 1; j >= 0; j--) {
      if (target < numbers[j]) {
        numbers[j + 1] = numbers[j];
      } else if (target > numbers[j]) {
        break;
      } else if (target == numbers[j]) {
        return "D";
      }
    }
    numbers[j + 1] = target;
  }
  return "U";
}
```

### ✍🏻 오답 노트

단순하게 생각했을 때는 배열의 모든 요소 하나하나를 배열을 끝까지 돌려가면서 중복을 체크한다면 n*n의 복잡도가 된다.

더 효율적인 방법이 있을 것이라고 생각하여 현재 주제인 정렬 알고리즘 중에 고민해보았을 때,

삽입 정렬은 앞에 먼저 정렬된 요소와 비교하며 정렬하는 특성이 있다. 그래서 정렬을 하는 과정에서도 중복된 값을 놓치지 않고 체크할 수 있다는 생각이 들었다.

### ✔️ 강의자료 코드
``` java
import java.util.*;
class Main {	
	public String solution(int n, int[] arr){
		String answer="U";
		Arrays.sort(arr);
		for(int i=0; i<n-1; i++){
			if(arr[i]==arr[i+1]){
				answer="D";
				break;
			}
		}
		return answer;
	}
	public static void main(String[] args){
		Main T = new Main();
		Scanner kb = new Scanner(System.in);
		int n=kb.nextInt();
		int[] arr=new int[n];
		for(int i=0; i<n; i++) arr[i]=kb.nextInt();
		System.out.println(T.solution(n, arr));
	}
}
```
