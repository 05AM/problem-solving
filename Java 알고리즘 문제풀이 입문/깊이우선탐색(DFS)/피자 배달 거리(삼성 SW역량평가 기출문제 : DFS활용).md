## â” ë¬¸ì œ
### âœ… ì„¤ëª…

NÃ—N í¬ê¸°ì˜ ë„ì‹œì§€ë„ê°€ ìˆìŠµë‹ˆë‹¤. ë„ì‹œì§€ë„ëŠ” 1Ã—1í¬ê¸°ì˜ ê²©ìì¹¸ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.

ê° ê²©ìì¹¸ì—ëŠ” 0ì€ ë¹ˆì¹¸, 1ì€ ì§‘, 2ëŠ” í”¼ìì§‘ìœ¼ë¡œ í‘œí˜„ë©ë‹ˆë‹¤. ê° ê²©ìì¹¸ì€ ì¢Œí‘œ(í–‰ë²ˆí˜¸, ì—´ ë²ˆí˜¸)ë¡œ í‘œí˜„ë©ë‹ˆë‹¤.

í–‰ë²ˆí˜¸ëŠ” 1ë²ˆë¶€í„° Në²ˆê¹Œì§€ì´ê³ , ì—´ ë²ˆí˜¸ë„ 1ë¶€í„° Nê¹Œì§€ì…ë‹ˆë‹¤.

ë„ì‹œì—ëŠ” ê° ì§‘ë§ˆë‹¤ â€œí”¼ìë°°ë‹¬ê±°ë¦¬â€ê°€ ì•˜ëŠ”ë° ê° ì§‘ì˜ í”¼ìë°°ë‹¬ê±°ë¦¬ëŠ” í•´ë‹¹ ì§‘ê³¼ ë„ì‹œì˜ ì¡´ì¬í•˜ëŠ”

í”¼ìì§‘ë“¤ê³¼ì˜ ê±°ë¦¬ ì¤‘ ìµœì†Œê°’ì„ í•´ë‹¹ ì§‘ì˜ â€œí”¼ìë°°ë‹¬ê±°ë¦¬â€ë¼ê³  í•œë‹¤.

ì§‘ê³¼ í”¼ìì§‘ì˜ í”¼ìë°°ë‹¬ê±°ë¦¬ëŠ” |x1-x2|+|y1-y2| ì´ë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, ë„ì‹œì˜ ì§€ë„ê°€ ì•„ë˜ì™€ ê°™ë‹¤ë©´

![image](https://github.com/user-attachments/assets/1e0e8c2e-831c-462e-af6e-345b3d6aff1c)

(1, 2)ì— ìˆëŠ” ì§‘ê³¼ (2, 3)ì— ìˆëŠ” í”¼ìì§‘ê³¼ì˜ í”¼ì ë°°ë‹¬ ê±°ë¦¬ëŠ” |1-2| + |2-3| = 2ê°€ ëœë‹¤.

ìµœê·¼ ë„ì‹œê°€ ë¶ˆê²½ê¸°ì— ì ‘ì–´ë“¤ì–´ ìš°í›„ì£½ìˆœ ìƒê²¼ë˜ í”¼ìì§‘ë“¤ì´ íŒŒì‚°í•˜ê³  ìˆìŠµë‹ˆë‹¤.

ë„ì‹œ ì‹œì¥ì€ ë„ì‹œì— ìˆëŠ” í”¼ìì§‘ ì¤‘ Mê°œë§Œ ì‚´ë¦¬ê³  ë‚˜ë¨¸ì§€ëŠ” ë³´ì¡°ê¸ˆì„ ì£¼ê³  íì—…ì‹œí‚¤ë ¤ê³  í•©ë‹ˆë‹¤.

ì‹œì¥ì€ ì‚´ë¦¬ê³ ì í•˜ëŠ” í”¼ìì§‘ Mê°œë¥¼ ì„ íƒí•˜ëŠ” ê¸°ì¤€ìœ¼ë¡œ ë„ì‹œì˜ í”¼ìë°°ë‹¬ê±°ë¦¬ê°€ ìµœì†Œê°€ ë˜ëŠ” Mê°œì˜ í”¼ìì§‘ì„ ì„ íƒí•˜ë ¤ê³  í•©ë‹ˆë‹¤.

ë„ì‹œì˜ í”¼ì ë°°ë‹¬ ê±°ë¦¬ëŠ” ê° ì§‘ë“¤ì˜ í”¼ì ë°°ë‹¬ ê±°ë¦¬ë¥¼ í•©í•œ ê²ƒì„ ë§í•©ë‹ˆë‹¤.

#### ìš”ì•½

- **í”¼ì ë°°ë‹¬ê±°ë¦¬** : í•´ë‹¹ ì§‘ê³¼ ë„ì‹œì˜ ì¡´ì¬í•˜ëŠ” í”¼ìì§‘ë“¤ê³¼ì˜ ê±°ë¦¬ ì¤‘ ìµœì†Œê°’ (|x1 - x2| + |y1 - y2|)
- **ë„ì‹œì˜ í”¼ì ë°°ë‹¬ê±°ë¦¬** : ê° ì§‘ë“¤ì˜ í”¼ì ë°°ë‹¬ ê±°ë¦¬ë¥¼ í•©í•œ ê²ƒ

ë„ì‹œì˜ í”¼ì ë°°ë‹¬ê±°ë¦¬ë¥¼ ìµœì†Œí•˜í•˜ëŠ” mê°œì˜ í”¼ìì§‘ì„ ì„ íƒ

### âœ… ì…ë ¥

ì²«ì§¸ ì¤„ì— N(2 â‰¤ N â‰¤ 50)ê³¼ M(1 â‰¤ M â‰¤ 12)ì´ ì£¼ì–´ì§„ë‹¤.

ë‘˜ì§¸ ì¤„ë¶€í„° ë„ì‹œ ì •ë³´ê°€ ì…ë ¥ëœë‹¤.

### âœ… ì¶œë ¥

ì²«ì§¸ ì¤„ì— Mê°œì˜ í”¼ìì§‘ì´ ì„ íƒë˜ì—ˆì„ ë•Œ ë„ì‹œì˜ ìµœì†Œ í”¼ìë°°ë‹¬ê±°ë¦¬ë¥¼ ì¶œë ¥í•œë‹¤.

#### ì˜ˆì‹œ ì…ë ¥ 1
```
4 4
0 1 2 0
1 0 2 1
0 2 1 2
2 0 1 2
```

#### ì˜ˆì‹œ ì¶œë ¥ 1
```
6
```

<br>

## âœğŸ» ìŠ¤ìŠ¤ë¡œ í’€ê¸°

### ğŸ’¡ DFS + ìˆœì—´ë¡œ ê²½ìš°ì˜ ìˆ˜ êµ¬í•˜ê¸°
``` java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Main {
    static int n;
    static int m;
    static int answer = Integer.MAX_VALUE;
    static int[][] map;
    static int[][] distances;
    static boolean[] visited;
    static int[] selected;
    static List<Position> stores = new ArrayList<>();
    static List<Position> houses = new ArrayList<>();

    static class Position {
        int row;
        int col;

        public Position(int row, int col) {
            this.row = row;
            this.col = col;
        }
    }

    private static int calculateCityMinDeliverDistance() {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (map[i][j] == 1) {
                    houses.add(new Position(i, j));
                } else if (map[i][j] == 2) {
                    stores.add(new Position(i, j));
                }
            }
        }

        visited = new boolean[stores.size()];
        distances = new int[stores.size()][houses.size()];

        for (int i = 0; i < stores.size(); i++) {
            for (int j = 0; j < houses.size(); j++) {
                distances[i][j] = calculateDistance(stores.get(i), houses.get(j));
            }
        }

        dfs(0);

        return answer;
    }

    private static int calculateDistance(Position store, Position house) {
        return Math.abs(store.row - house.row) + Math.abs(store.col - house.col);
    }

    private static void dfs(int level) {
        if (level >= m) {
            int sum = 0;

            for (int houseNo = 0; houseNo < houses.size(); houseNo++) {
                int min = Integer.MAX_VALUE;

                for (int storeNo : selected) {
                    min = Math.min(min, distances[storeNo][houseNo]);
                }

                sum += min;
            }

            answer = Math.min(answer, sum);
        } else {
            for (int i = 0; i < stores.size(); i++) {
                if (!visited[i]) {
                    selected[level] = i;
                    visited[i] = true;

                    dfs(level + 1);

                    visited[i] = false;
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        map = new int[n][n];
        selected = new int[m];

        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                map[row][col] = in.nextInt();
            }
        }

        System.out.println(calculateCityMinDeliverDistance());
    }
}
```

ì´ ë¬¸ì œë¥¼ í’€ê¸° ì „ì— ì„¸ì› ë˜ ì „ëµì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

1. ê° ì§‘ê³¼ í”¼ìì§‘ ê°„ì˜ ìµœì†Œ ê±°ë¦¬ë¥¼ ê³„ì‚°í•œë‹¤.
2. mê°œì˜ í”¼ìì§‘ì„ ì„ íƒí•˜ëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ ê°ê° dfs íƒìƒ‰í•œë‹¤.
3. ê²°ê³¼ê°€ í˜„ì¬ ìµœì†Œë³´ë‹¤ ì‘ì€ ê²½ìš° ê°’ì„ ê°±ì‹ í•œë‹¤.

ìœ„ì˜ ê³„íšëŒ€ë¡œ êµ¬í˜„í•˜ê¸´ í–ˆëŠ”ë° ì‹œê°„ ì´ˆê³¼ë¡œ ëª‡ëª‡ì˜ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ í†µê³¼í•˜ì§€ ëª»í–ˆë‹¤.

ì•„ë¬´ë˜ë„ ê°€ê²Œì™€ ì§‘ì„ ì°¾ìœ¼ë©´ì„œ 1ë²ˆ, ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ë©´ì„œ 1ë²ˆ ì™„ì „ íƒìƒ‰ì„ í•˜ê³ , ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ ì¡°í•©í•´ì„œ í•˜ë‹¤ë³´ë‹ˆ ê·¸ëŸ° ê²ƒ ê°™ë‹¤.

ê²½ìš°ì˜ ìˆ˜ë¥¼ ë”°ì§€ëŠ” ê²ƒì„ ìˆœì—´ì´ ì•„ë‹ˆë¼ ì¡°í•©ìœ¼ë¡œ ë°”ê¿”ì•¼ê² ë‹¤.

<br>

### ğŸ’¡ DFS + ì¡°í•©ìœ¼ë¡œ ê²½ìš°ì˜ ìˆ˜ êµ¬í•˜ê¸°
``` java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Main {
    static int n;
    static int m;
    static int answer = Integer.MAX_VALUE;
    static int[][] map;
    static int[][] distances;
    static boolean[] visited;
    static int[] selected;
    static List<Position> stores = new ArrayList<>();
    static List<Position> houses = new ArrayList<>();

    static class Position {
        int row;
        int col;

        public Position(int row, int col) {
            this.row = row;
            this.col = col;
        }
    }

    private static int calculateCityMinDeliverDistance() {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (map[i][j] == 1) {
                    houses.add(new Position(i, j));
                } else if (map[i][j] == 2) {
                    stores.add(new Position(i, j));
                }
            }
        }

        visited = new boolean[stores.size()];
        distances = new int[stores.size()][houses.size()];

        for (int i = 0; i < stores.size(); i++) {
            for (int j = 0; j < houses.size(); j++) {
                distances[i][j] = calculateDistance(stores.get(i), houses.get(j));
            }
        }

        dfs(0, 0);

        return answer;
    }

    private static int calculateDistance(Position store, Position house) {
        return Math.abs(store.row - house.row) + Math.abs(store.col - house.col);
    }

    private static void dfs(int level, int start) {
        if (level >= m) {
            int sum = 0;

            for (int houseNo = 0; houseNo < houses.size(); houseNo++) {
                int min = Integer.MAX_VALUE;

                for (int storeNo : selected) {
                    min = Math.min(min, distances[storeNo][houseNo]);
                }

                sum += min;
            }

            answer = Math.min(answer, sum);
        } else {
            for (int i = start; i < stores.size(); i++) {
                if (!visited[i]) {
                    selected[level] = i;
                    visited[i] = true;

                    dfs(level + 1, i + 1);

                    visited[i] = false;
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        map = new int[n][n];
        selected = new int[m];

        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                map[row][col] = in.nextInt();
            }
        }

        System.out.println(calculateCityMinDeliverDistance());
    }
}
```

ì´ë²ˆ ì½”ë“œëŠ” ì¡°í•©ìœ¼ë¡œ ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í–ˆë‹¤.

ê²½ìš°ì˜ ìˆ˜ì— ìˆœì„œê°€ ë“¤ì–´ê°€ì§€ ì•Šìœ¼ë‹ˆ ì¤‘ë³µì´ ì¤„ì–´ë“¤ì–´ ìµœì†Ÿê°’ì„ êµ¬í•˜ëŠ”ë° ì‹œí–‰í•˜ëŠ” íšŸìˆ˜ê°€ ë” ì ì–´ì¡Œë‹¤.

ë°©ë²•ì€ dfs ë‚´ë¶€ì˜ ë°˜ë³µë¬¸ì„ ëŒë¦´ ë•Œ start ì¸ë±ìŠ¤ë¥¼ ë‹¤ìŒ dfs í˜¸ì¶œì— ë„˜ê²¨ì£¼ì–´ì„œ í•´ë‹¹ ì‹œì‘ ì¸ë±ìŠ¤ ì´í›„ë¶€í„° í”¼ì ê°€ê²Œë¥¼ ì„ íƒí•˜ê²Œ í•˜ëŠ” ê²ƒì´ë‹¤.

<br>

## ğŸ“– ê°•ì˜ìë£Œ ì½”ë“œ

``` java
import java.util.*;
class Point{
	public int x, y;
	Point(int x, int y){
		this.x=x;
		this.y=y;
	}
}
class Main {
	static int n, m, len, answer=Integer.MAX_VALUE;
	static int[] combi;
	static ArrayList<Point> hs, pz;
	public void DFS(int L, int s){
		if(L==m){
			int sum=0;
			for(Point h : hs){
				int dis=Integer.MAX_VALUE;
				for(int i : combi){
					dis=Math.min(dis, Math.abs(h.x-pz.get(i).x)+Math.abs(h.y-pz.get(i).y));
				}
				sum+=dis;
			}
			answer=Math.min(answer, sum);
		}
		else{
			for(int i=s; i<len; i++){
				combi[L]=i;
				DFS(L+1, i+1);
			}
		}
	}

	public static void main(String[] args){
		Main T = new Main();
		Scanner kb = new Scanner(System.in);
		n=kb.nextInt();
		m=kb.nextInt();
		pz=new ArrayList<>();
		hs=new ArrayList<>();
		for(int i=0; i<n; i++){
			for(int j=0; j<n; j++){
				int tmp=kb.nextInt();
				if(tmp==1) hs.add(new Point(i, j));
				else if(tmp==2) pz.add(new Point(i, j));
			}
		}
		len=pz.size();
		combi=new int[m];
		T.DFS(0, 0);
		System.out.println(answer);
	}
}
```

<br>

## âœ”ï¸ ì˜¤ë‹µ ë…¸íŠ¸

ë‹¤ìŒë¶€í„°ëŠ” ìˆœì„œê°€ í•„ìš”í•œ ê²½ìš°ì˜ ìˆ˜ê°€ ì•„ë‹ˆë¼ë©´ ë¬´ì¡°ê±´ ì¡°í•©ìœ¼ë¡œ êµ¬í•˜ê¸° ìœ„í•´ ë…¸ë ¥í•´ì•¼ê² ë‹¤.
