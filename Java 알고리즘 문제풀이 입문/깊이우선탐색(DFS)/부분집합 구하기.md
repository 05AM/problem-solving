## ❔ 문제
### ✅ 설명
자연수 N이 주어지면 1부터 N까지의 원소를 갖는 집합의 부분집합을 모두 출력하는 프로그램을 작성하세요.

### ✅ 입력
첫 번째 줄에 자연수 N(1<=N<=10)이 주어집니다.

### ✅ 출력
첫 번째 줄부터 각 줄에 하나씩 부분집합을 아래와 출력예제와 같은 순서로 출력합니다.

단 공집합은 출력하지 않습니다.

#### 예시 입력 1
``` java
3
```

#### 예시 출력 1
``` java
 1 2 3
 1 2
 1 3
 1
 2 3
 2
 3
```

<br>

## 💡 접근 방법
1. 부분 집합의 각 원소는 부분집합에 포함되거나 포함되지 않을 수 있다.
공집합 포함 모든 경우의 수: 2^(원소 개수)

2. DFS는 재귀적으로 호출되면서 모든 가능한 선택(포함 또는 미포함)을 탐색한다.

3. `check` 배열을 사용하여 각 원소가 부분집합에 포함되는지를 기록한다.

4. `dfs(level)` 메서드는 현재 원소(`level`)가 부분집합에 포함되는지 **결정**하고, 다음 레벨로 재귀 호출을 한다.
level이 `n + 1`에 도달하면 현재까지 선택된 원소들을 기반으로 부분집합을 출력한다.

<br>

## 📖 강의자료 코드

``` java
class Main {

	static int n = 3;
	static int[] check = new int[n + 1];

	public void dfs(int level) {
		if (level == n + 1) {
			StringBuilder result = new StringBuilder();

			for (int i = 1; i <= n; i++) {
				if (check[i] == 1) {
					result.append(i).append(" ");
				}
			}

			if (result.length() != 0) {
				System.out.println(result.toString());
			}
		} else {
			check[level] = 1;
			dfs(level + 1);

			check[level] = 0;
			dfs(level + 1);
		}
	}

	public static void main(String[] args) {
		Main main = new Main();

		main.dfs(1);
	}
}
```

<br>

## ✔️ 오답 노트

처음부터 DFS로 구현한다는 것을 알고도 왜 이 알고리즘을 사용해야 하는지, 어떻게 구현해야할지 감이 잡히지 않았다.

그래도 DFS가 재귀적으로 호출되며 모든 경우의 수를 다 탐색한다는 특징을 갖고 있다는 점이 이후 문제풀이에서 고려해볼만한 포인트인 것 같다.

또한 경로를 거치면서 포함/미포함을 **결정**하고 반복 종료 조건에서 모든 것이 결정된 것을 출력한다는 것이 인상깊었다.

반복 종료 조건 내에서 공집합은 출력하지 않는다던가 하는 다른 조건도 만족시킬 수 있다는 것을 알았다.

또한 이전까지는 탐색할 구현된 그래프가 꼭 있어야한다고 생각했는데 
check 배열로 포함 여부와 원소의 값을 인덱스로 처리하여 딱히 필요없었던 것 같다.

하지만 이건 원소의 값이 연속되기 때문에 필요없는 것 같고, 연속되지 않을 때의 경우에는 어떻게 구현해야 할지 고민해봐야할 것 같다.

결론적으로 이 **부분집합 구하기** 문제에서 dfs를 사용한 이유를 2가지 생각해볼 수 있었다.

1. 각 원소는 부분집합에 포함 / 미포함 이라는 2가지 선택지에서 고를 수 밖에 없다. => 이진 트리

각 노드는 `원소 n 포함` `원소 n 미포함` 의 의미를 가지고 있고, 각 경로 자체가 부분 집합 중 1개의 경우의 수이다.

2. dfs는 모든 경로를 탐색한다.

모든 경로를 탐색하기에 공집합을 포함한 모든 부분 집합을 알 수 있다.
