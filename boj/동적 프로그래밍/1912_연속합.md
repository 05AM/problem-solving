## ❔ 문제
### ✅ 설명
n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.

예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.

### ✅ 입력
첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

### ✅ 출력
첫째 줄에 답을 출력한다.

#### 예시 입력 1
```
10
10 -4 3 1 5 6 -35 12 21 -1
```

#### 예시 출력 1
```
33
```

<br>

## ✍🏻 스스로 풀기

### 💡 동적 프로그래밍: 최근 부분수열 합과 현재 값 크기 비교

``` java
    private static int solution(int n, int[] sequence) {
        int currentSum = sequence[0];
        int max = sequence[0];

        for (int i = 1; i < n; i++) {
            currentSum = Math.max(currentSum + sequence[i], sequence[i]);
            max = Math.max(max, currentSum);
        }

        return max;
    }
```

<br>

## ✔️ 오답 노트

처음에는 2차원 배열로 인덱스 몇부터 몇까지의 합을 저장하면서 구하려고 했다. 하지만 어차피 모든 경우를 다 계산해보는건 똑같았다.

지금까지는 동적 프로그래밍에 대해 오해를 하고 있었던 것 같은데, 나는 동적 프로그래밍에서 사용하는 기법인 메모이제이션에만 초점을 맞추고 있었던 것 같다. 또한 결과를 모두 저장해야한다는 편견에도 빠져있었다.

하지만 동적 프로그래밍의 정의를 보면, 무작정 결과를 저장하는 것이 아니라 **프로그램 실행 중에 문제를 해결하기 위해 결정된 부분 해결 방법들을 재사용하는 과정**이다.

문제를 작은 부분 문제로 나누고, 각 부분 문제의 결과를 저장해 놓고, 필요할 때 다시 활용한다. '동적'이라는 말은 여기서 최적 해를 찾는 과정이 실행 시간 동안 변화하고 적응한다는 것을 의미한다.


여기서 정적인 방식인 그리디 알고리즘과 다른 점은 **부분 문제의 중복**이 존재해, 그 결과를 저장해뒀다가 다시 사용한다는 것에 있다.

그리디는 그 순간에서의 최적의 해를 구하고 이전 결과를 기억하지 않지만 동적 프로그래밍은 이전 결과를 필요하다면 재사용한다.


이 문제에서는 이전 요소까지 포함한 수열의 최대 부분합을 구한다는 부분 문제가 존재하고 그걸 다음 요소에 적용하며 답을 찾아간다.
음수가 존재해서 현재 선택한 요소가 최적의 해가 아닐 수 있으므로 그리디가 아닌 동적 프로그래밍을 사용한다.
