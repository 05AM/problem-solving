## ❔ 문제
### ✅ 설명
```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```
위 그림은 크기가 5인 정수 삼각형의 한 모습이다.

맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.

삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.

### ✅ 입력
첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.

### ✅ 출력
첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.

#### 예시 입력 1
```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

#### 예시 출력 1
```
30
```

<br>

## ✍🏻 스스로 풀기

### 💡 동적 프로그래밍: 현재 위치까지의 최대값 구하기

``` java
private static int solution(int n, int[][] costs) {
    int[][] dp = new int[n][n];

    dp[0][0] = costs[0][0];

    for (int row = 1; row < n; row++) {
        for (int col = 0; col <= row; col++) {
            if (col == 0) {
                dp[row][col] = dp[row - 1][col] + costs[row][col];
                continue;
            }

            if (col == row) {
                dp[row][col] = dp[row - 1][col - 1] + costs[row][col];
                continue;
            }

            dp[row][col] = Math.max(dp[row - 1][col], dp[row - 1][col - 1]) + costs[row][col];
        }
    }

    int max = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        max = Math.max(max, dp[n - 1][i]);
    }

    return max;
}
```
<br>

### 💡 인상적인 코드: 아래에서 위로 구하기
``` java
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt(), i = 0, j;
        int[][] d = new int[n][n];

        for (; i < n; i++)
            for (j = 0; j <= i; d[i][j++] = s.nextInt());

        for (i = n - 2; i >= 0; i--)
            for (j = 0; j <= i; j++)
                d[i][j] = d[i][j] + Math.max(d[i + 1][j], d[i + 1][j + 1]);

        System.out.print(d[0][0]);
    }
}
```

나는 꼭대기부터 경로를 따라 최댓값을 구한 반면에 위 코드는 아래서부터 위로 올라가며 구했다.

내 코드에서 위에서 아래로 내려가려면 인덱스가 각 층의 끝일 때 부모가 하나만 있어 최댓값을 구하는 공식이 달라졌다. 그래서 조건문을 달 수 밖에 없었는데, 
위 코드는 아래에서 위로 올라가다보니 무조건 자식이 2개라서 그 중에 고르면 되어 코드가 훨씬 간단해졌다.

부모는 1개일수도, 2개일수도 있지만, 자식은 무조건 2개이기 때문에 조건이 통일된 것 같다.

이렇게 아래에서 위로 올라가는 방식도 좋은 것 같다. 지금 목적은 최댓값 1개를 구하는 것이지 각 경로의 최댓값을 구하는 것이 아니기 때문이다.

<br>

## ✔️ 오답 노트

이번에 동적 프로그래밍 문제를 몇 개 풀어보며 사고방식에 대해 정리해보았다.

한 문제를 부분 문제로 쪼개고, 그 부분 문제의 답을 이용해서 다음 부분문제를 해결하는 알고리즘 설계 기법인데, 이 과정에서 중복되는 결과가 있기 때문에 이미 계산한 결과를 중복으로 계산하는 것을 막기
위해서 그 값을 저장하는 메모이제이션이라는 기법을 사용한다.

현재 얻어야하는 값이 이전에 계산한 값에 의존할 때 사용할 수 있다.

우선은 현재까지의 최적 해를 찾는 것에 집중하고, 이전까지의 최적 해를 저장하면서 답을 구하는 식을 이용하여 각 단계의 최적 해를 구한다.
